---
layout:       post
title:        "使用 Unix Domain Sockets 在不同进程间传递文件句柄"
author:       "shensunbo"
header-style: text
catalog:      true
tags:
    - Unix Domain Sockets
    - fd
---
# sender 
```
#include <iostream>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <fcntl.h>

#define SOCKET_NAME "/tmp/my_socket"

void send_fd(int socket, int fd_to_send) {
    const char *str1 = "Hello, ";
    struct msghdr msg = {};
    struct iovec io = { .iov_base = (void *)str1, .iov_len = 1 };
    char control[CMSG_SPACE(sizeof(int))];
    msg.msg_iov = &io;
    msg.msg_iovlen = 1;
    msg.msg_control = control;
    msg.msg_controllen = sizeof(control);

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    *((int *)CMSG_DATA(cmsg)) = fd_to_send;

    if (sendmsg(socket, &msg, 0) == -1) {
        perror("sendmsg");
    }
}

int main() {
    int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    struct sockaddr_un server_addr = { .sun_family = AF_UNIX, .sun_path = SOCKET_NAME };

    unlink(SOCKET_NAME);
    bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(sockfd, 1);

    std::cout << "Awaiting connection..." << std::endl;
    int client_sock = accept(sockfd, NULL, NULL);
    std::cout << "Connection accepted!" << std::endl;

    int file_fd = open("example.txt", O_RDWR | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);
    send_fd(client_sock, file_fd);
    std::cout << "File descriptor sent!" << std::endl;

    close(file_fd);
    close(client_sock);
    close(sockfd);
    return 0;
}

```

# receiver
```
#include <iostream>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <fcntl.h>

#define SOCKET_NAME "/tmp/my_socket"

int receive_fd(int socket) {
    struct msghdr msg = {};
    char buf[1];
    struct iovec io = { .iov_base = buf, .iov_len = sizeof(buf) };
    char control[CMSG_SPACE(sizeof(int))];
    msg.msg_iov = &io;
    msg.msg_iovlen = 1;
    msg.msg_control = control;
    msg.msg_controllen = sizeof(control);

    if (recvmsg(socket, &msg, 0) <= 0) {
        perror("recvmsg");
        return -1;
    }

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    return *((int *)CMSG_DATA(cmsg));
}

int main() {
    int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    struct sockaddr_un server_addr = { .sun_family = AF_UNIX, .sun_path = SOCKET_NAME };

    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    std::cout << "Connected to sender!" << std::endl;

    int fd_received = receive_fd(sockfd);
    if (fd_received != -1) {
        std::cout << "File descriptor received: " << fd_received << std::endl;

        // Use the file descriptor (e.g., read/write to the file it points to)
        // Don't forget to close it eventually
        char buffer[100];
        read(fd_received, buffer, sizeof(buffer));
        std::cout << "Read from file: " << buffer << std::endl;
        close(fd_received);
    }

    close(sockfd);
    return 0;
}

```