---
layout:       post
title:        "尝试的优化渲染速度的方法"
author:       "shensunbo"
header-style: text
catalog:      true
tags:
    - renderer
    - render
    - opengl
---
# 使用perf等工具看一下火焰图，检查一下时间都去哪了👀
![FlameGraph](/img/in-post/blah/FlameGraph.png)

# 减少uniform更新次数
## 使用UBO将多个uniform打包，并绑定到相应的mesh上，比如材质属性和纹理加载状态
> TODO：会增加GPU内存开销，没具体验证过实际影响，也不一定是最佳实践 🤷‍♂️
```
layout (std140) uniform MaterialBlock {
    vec4 materialDiffuseColor;
    vec4 materialSpecularColor;
    float Opacity;
    float Shininess;
    float ShininessStrength;
    bool texture_diffuse_load;
    bool texture_specular_load;
    bool texture_normal_load;
    bool texture_ao_load;
    bool texture_alpha_load;
    bool texture_roughness_load;
    bool texture_metallic_load;
    bool texture_emissive_load;
} material;
```


## 去重，能不更新就不更新
通过一定的逻辑和判断等等，减少不必要的uniform更新，比如在控制车门旋转的时候，这个车门的部件是可以共享一组uniform的，不需要为每个部件都更新一次设置。

# png格式的纹理加载速度慢，使用其他GPU友好的格式
尝试了KTX格式，会比解码png快不少，大概几倍的样子，但上传到GPU的接口也是很耗时的，即使使用这种格式也需要多线程异步加载。在OpenGL中需要做上下文贡献。
TODO: 有时间的话研究一下 🤫

# 多线程加载纹理资源
在初始化的时候使用多线程一次性将所有图像资源都加载到内存中，使用的时候直接查找。会比线型加载快很多。在模型加载解析完成之后统一释放资源。
可以参考这笔提交[github about optimization](https://github.com/shensunbo/render_explore_by_opengl/commit/e9a506cb7363e5f6f728b820eb4274288edc79ee)

## 缺点
1. 内存开销增加
2. CPU loading 很高
3. 上传到GPU仍然需要时间

## 待办
1. 探索生成纹理及上传到GPU的这个过程是否也可以做异步
2. 使用的是stbi软解方式，在特定的环境中可以有硬解接口

# 能在顶点着色器完成的计算就不要放到片段着色器

# 能在CPU完成的计算就不要放到GPU，比如MVP矩阵的计算

# 优化模型加载速度，assimp某些配置加载速度慢
